# This workflow will build a .NET project
# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-net

name: CI/CD .NET + Docker

on:
  push:
    branches:
      - main
      - develop   # ch·ªâ ch·∫°y khi push v√†o branch development
  pull_request:
    branches:
      - develop

jobs:
  build-and-push:
    runs-on: self-hosted

    steps:
      - name: Checkout source
        uses: actions/checkout@v3

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0

      - name: Restore
        run: dotnet restore | Tee-Object -FilePath restore.log -Append

      - name: Build
        run: dotnet build --configuration Release --no-restore | Tee-Object -FilePath build.log -Append
        
      - name: Test
        run: dotnet test --no-build --verbosity normal | Tee-Object -FilePath test.log -Append
        
      - name: Login to DockerHub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and Push Docker image
        run: |
          docker buildx build `
            --file ./WebApplication2/Dockerfile `
            --tag ngoanh93/yourapp:latest `
            --push `
            . | Tee-Object -FilePath build_image.log -Append
          
      - name: Pull latest image
        run: docker pull ngoanh93/yourapp:latest | Tee-Object -FilePath pull_image.log -Append

      - name: Stop old container
        run: |
          if (docker ps -q -f "name=yourapp") {
              docker rm -f yourapp | Tee-Object -FilePath stop_image.log -Append
          } else {
              Write-Output "Container yourapp not found, skip remove" | Tee-Object -FilePath stop_image.log -Append
          }
      - name: Run new container
        run: |
          $workspace = "${{ github.workspace }}"
          $configPath = Join-Path $workspace "WebApplication2\appsettings.Development.json"

          # üßπ X√≥a image ngoanh93/yourapp kh√¥ng c√≤n d√πng
          docker images --filter "reference=ngoanh93/yourapp" --format "{{.ID}}" |
            ForEach-Object {
              if (-not (docker ps -a --filter "ancestor=$_ " --format "{{.ID}}")) {
                  "Deleting unused image ID: $_" | Tee-Object -FilePath run_image.log -Append
                  docker rmi -f $_ | Tee-Object -FilePath run_image.log -Append
              }
            }
          $cmd = "docker run -d --name yourapp -p 9600:8080 -e ASPNETCORE_ENVIRONMENT=Development -v ${configPath}:/app/appsettings.Development.json --network=postgres_postgres ngoanh93/yourapp:latest"
      
          # Log c·∫£ l·ªánh v√† output
          ">>> Running: $cmd" | Tee-Object -FilePath run_image.log -Append
          Invoke-Expression $cmd | Tee-Object -FilePath run_image.log -Append
          
      - name: Collect error logs
        if: failure()
        run: |
          "==== ERROR SUMMARY ====" | Out-File error_log.txt -Encoding utf8
          $steps = @(
            @{ Name = "Restore dependencies"; File = "restore.log" },
            @{ Name = "Build project"; File = "build.log" },
            @{ Name = "Test project"; File = "test.log" },
            @{ Name = "Build and Push Docker image"; File = "build_image.log" },
            @{ Name = "Pull image"; File = "pull_image.log" },
            @{ Name = "Stop old container"; File = "stop_image.log" },
            @{ Name = "Run new container"; File = "run_image.log" }
          )
          foreach ($s in $steps) {
            if ((Test-Path $s.File) -and (Select-String -Path $s.File -Pattern "error")) {
              "Loi o buoc $($s.Name):" | Out-File error_log.txt -Append -Encoding utf8
              Select-String -Path $s.File -Pattern "error" | ForEach-Object { $_.Line } | Out-File error_log.txt -Append -Encoding utf8
            }
          }
          "========================" | Out-File error_log.txt -Append -Encoding utf8

          # Th√™m 50 d√≤ng cu·ªëi t·ª´ build.log ƒë·ªÉ d·ªÖ debug
          if (Test-Path build.log) {
            "==== Last 50 lines of build.log ====" | Out-File error_log.txt -Append -Encoding utf8
            Get-Content build.log -Tail 50 | Out-File error_log.txt -Append -Encoding utf8
          }
          Write-Host "===== Error log content ====="
          Get-Content error_log.txt
      
      - name: Notify Telegram (success)
        if: success()   # lu√¥n g·ª≠i th√¥ng b√°o (k·ªÉ c·∫£ fail)
        run: |
          $TOKEN = "${{ secrets.TELEGRAM_BOT_TOKEN }}"
          $CHAT_ID = "${{ secrets.TELEGRAM_CHAT_ID }}"

          $SERVICE_NAME = "yourapp"   # thay b·∫±ng t√™n service th·∫≠t
          $PROJECT_URL = "https://github.com/${{ github.repository }}.git"
          $USER_COMMIT = git log -1 --pretty=format:'%an <%ae>'
          $COMMIT_TITLE = git log -1 --pretty=%s
          $COMMIT_SHA = git rev-parse HEAD
          $PIPELINE_URL = "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          $USER_CICD = "${{ github.actor }}"

          $MESSAGE = @"
          ‚úÖ CICD d·ª± √°n $SERVICE_NAME ($env:GITHUB_REF_NAME) th√†nh c√¥ng:
            
            Service name: $SERVICE_NAME
            Project url: $PROJECT_URL
            User commit: $USER_COMMIT
            Commit title: $COMMIT_TITLE
            Commit SHA: $COMMIT_SHA
            
            Pipeline url: $PIPELINE_URL
            User CICD: $USER_CICD
          "@
          $Body = @{
            chat_id = $CHAT_ID
            text    = $MESSAGE
          } | ConvertTo-Json -Depth 3 -Compress
          $Utf8Body = [System.Text.Encoding]::UTF8.GetBytes($Body)
          Invoke-RestMethod -Uri "https://api.telegram.org/bot$TOKEN/sendMessage" `
            -Method Post `
            -ContentType "application/json; charset=utf-8" `
            -Body $Utf8Body
            
      - name: Notify Telegram (failure)
        if: failure()   # lu√¥n g·ª≠i th√¥ng b√°o (k·ªÉ c·∫£ fail)
        run: |
          $TOKEN = "${{ secrets.TELEGRAM_BOT_TOKEN }}"
          $CHAT_ID = "${{ secrets.TELEGRAM_CHAT_ID }}"

          $SERVICE_NAME = "yourapp"   # thay b·∫±ng t√™n service th·∫≠t
          $PROJECT_URL = "https://github.com/${{ github.repository }}.git"
          $USER_COMMIT = git log -1 --pretty=format:'%an <%ae>'
          $COMMIT_TITLE = git log -1 --pretty=%s
          $COMMIT_SHA = git rev-parse HEAD
          $PIPELINE_URL = "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          $USER_CICD = "${{ github.actor }}"
          
          # L·∫•y log l·ªói (20 d√≤ng cu·ªëi)
          $LogFile = "error_log.txt"
          
          $MESSAGE = @"
          ‚ùå CICD d·ª± √°n $SERVICE_NAME ($env:GITHUB_REF_NAME) th·∫•t b·∫°i:
            
            Service name: $SERVICE_NAME
            Project url: $PROJECT_URL
            User commit: $USER_COMMIT
            Commit title: $COMMIT_TITLE
            Commit SHA: $COMMIT_SHA
            
            Pipeline url: $PIPELINE_URL
            User CICD: $USER_CICD
          "@
          $Body = @{
            chat_id = $CHAT_ID
            text    = $MESSAGE
          } | ConvertTo-Json -Depth 3 -Compress
          $Utf8Body = [System.Text.Encoding]::UTF8.GetBytes($Body)
          Invoke-RestMethod -Uri "https://api.telegram.org/bot$TOKEN/sendMessage" `
            -Method Post `
            -ContentType "application/json; charset=utf-8" `
            -Body $Utf8Body

          # G·ª≠i file log (multipart/form-data)
          $url = "https://api.telegram.org/bot$TOKEN/sendDocument"
          $form = @{
            chat_id  = $CHAT_ID
            document = Get-Item $LogFile
          }
          $boundary = [System.Guid]::NewGuid().ToString()
          $LF = "`r`n"

          $fileBytes = [System.IO.File]::ReadAllBytes($LogFile)
          $enc = [System.Text.Encoding]::GetEncoding("iso-8859-1")
          $fileContent = $enc.GetString($fileBytes)

          $bodyLines = (
            "--$boundary",
            "Content-Disposition: form-data; name=`"chat_id`"$LF",
            "$CHAT_ID$LF",
            "--$boundary",
            "Content-Disposition: form-data; name=`"document`"; filename=`"$LogFile`"",
            "Content-Type: text/plain$LF",
            "$fileContent$LF",
            "--$boundary--$LF"
          )

          $body = ($bodyLines -join $LF)
          Invoke-RestMethod -Uri $url -Method Post -ContentType "multipart/form-data; boundary=$boundary" -Body $body

